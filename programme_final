import numpy as np
from random import randint, random
from matplotlib import pyplot as plt
import matplotlib.animation as animation
import time

### CONSTANTES #########################################################

I_TYPE_CASE = 0
N_ITERATIONS = 25
longueur_parking = 18
largeur_parking = 18
I_SORTIE,J_SORTIE = largeur_parking//2,longueur_parking-1

### FONCTIONS GENERALES ################################################

def parking_cool_test(longueur,largeur):
        
    bords = -np.ones(longueur,dtype=int)

    parking = -np.ones((largeur,longueur),dtype=int)
    
    for x in range(3,longueur-1):
        if x%4 == 1 or x%4 == 2:
            for y in range(2,largeur-2):
                parking[y,x] = 1
        else:
            parking[:,x] = 0 # files vides

    parking[largeur//2],parking[largeur//2-1] = 0,0 # création de la route principale 
    parking[0,3:-1],parking[1,3:-1],parking[-1,3:-1],parking[-2,3:-1] = 0,0,0,0 # création des routes des fins de files
    
    parking = np.append(bords,parking).reshape(largeur+1,longueur)
    parking = np.append(parking,bords).reshape(largeur+2,longueur)

    T = np.array([True]*longueur*(largeur+2)).reshape(largeur+2,longueur)

    return np.array([parking,T,T,T,T])

def creation_random_parking(longueur_parking,largeur_parking):
    """Crée un parking aléatoirement.

    Parameters
    ----------
    longueur_parking: int
    largeur_parking: int

    Returns
    -------
    array
        tableau numpy LxN composé de quintuplets [genre,dir1,dir2,dir3,dir4]
        genre: int
            entier décrivant la nature du bloc pouvant valoir -1 (mur), 0 (route) ou 1 (place)
        dir1 (resp. dir2, ..): bool
            booléen vrai si la voiture peut avancer devant (resp. à gauche,..) par rapport à l'entrée. [cf fichier paint]

        parking = | [0,True,True,False,False] , ... , [-1,True,True,False,True] |

        Correspondant à :

                    | [0,True,True,False,False]             ...             [-1,True,True,False,True] |
                    |            ...                                                   ...            |
                    |            ...                                                   ...            |
        parking =   |            ...                                                   ...            |
                    |            ...                                                   ...            |
                    |            ...                                                   ...            |
                    | [-1,True,False,True,True]             ...             [-1,True,True,False,True] |

    """

    P = []
    for _ in range(largeur_parking):
        for __ in range(longueur_parking):
            P.append([randint(-1,1),[True,False][randint(0,1)],[True,False][randint(0,1)],[True,False][randint(0,1)],[True,False][randint(0,1)]])
    
    P[longueur_parking*(largeur_parking//2)][0] = 0 # on impose que l'entrée ne soit pas condamnée
    P[longueur_parking*(largeur_parking//2+1)-1][0] = 0 # de même pour la sortie
    
    P = np.array(P,dtype=list)
    parking = np.empty(5,dtype=list)
    for i in range(5):
        parking[i] = P[:,i].reshape((largeur_parking,longueur_parking))

    return parking

def dijkstra(parking, i1, j1, i2, j2):
    """
    Algorithme cherchant avec la méthode de Dijkstra un chemin liant deux points (i1,j1) et (i2,j2) dans arr
    Parameters
    ----------
    parking: array
    i1: int
    j1: int
    i2: int
    j2: int

    Returns
    -------
    array
        liste des coordonnées successives des points du chemin liant (i1,j1) et (i2,j2).
    """
    taille_parking = parking[0].shape
    indices_visités = np.full(taille_parking, False)
    queue = [(i1, j1)] # queue pour garder les indices que l'on doit visiter
    ind_precedents = {} # dico pour garder les indices précédemment étudiés pour chaque indice
    indices_visités[i1, j1] = True

    while queue: # tant qu'il y a des indices à étudier
        i, j = queue.pop(0) # on prend le prochain indice dans la queue
        if i == i2 and j == j2: # si l'indice actuel est arrivé sur l'indice de destination on arrête le programme
            break

        voisinage = [(i, j+1), (i-1, j), (i, j-1), (i+1, j)] # devant, gauche, derrière, droite

        for num_voisin in range(len(voisinage)):

            i_vois, j_vois = voisinage[num_voisin]

            if 0 <= i_vois < taille_parking[0] and 0 <= j_vois < taille_parking[1] and not indices_visités[i_vois, j_vois]: # si la case est pas visitée est qu'il n'y a pas de OOB
                
                accessible = parking[num_voisin+1][j,i] # booléen vrai si la case (i_vois,j_vois) est accessible depuis (i,j)
                if accessible and parking[0][j_vois,i_vois] == 0: # si la case est accessible physiquement et que c'est de la route
                    indices_visités[i_vois, j_vois] = True # le voisin est désormais visité
                    queue.append((i_vois, j_vois)) # on l'ajoute parmi les prochains a devoir être visité

                    ind_precedents[(i_vois, j_vois)] = (i, j) # on garde les indices précédents pour i_vois,j_vois
                accessible = False
    chemin = []

    i, j = i2, j2 # on part de l'arrivée
    while (i, j) in ind_precedents:
        chemin.append((i, j))
        i, j = ind_precedents[(i, j)]

    return list(reversed(chemin))

def directions_dispo(x,y,direction,parking):
    devant_dispo = parking[1][y,x] # /!\ ce n'est pas devant elle mais devant par rapport à l'entrée
    gauche_dispo = parking[2][y,x]
    droite_dispo = parking[3][y,x]
    derriere_dispo = parking[4][y,x]

    candidats_dir_dispo = [[devant_dispo,y,x+1],[gauche_dispo,y-1,x],[droite_dispo,y+1,x],[derriere_dispo,y,x-1]]
    return candidats_dir_dispo            

def etapes_sortie(parking):
    '''
    Fonction renvoyant un dictionnaire avec pour chaque place le chemin à parcourir pour sortir du parking
    '''
    chemins = {}
    coordonnees_places = np.argwhere(parking[0]==1)
    #print(coordonnees_places)
    for i_place,j_place in coordonnees_places:
        chemins[(i_place,j_place)] = dijkstra(parking,i_place,j_place,J_SORTIE-1,I_SORTIE) + [(J_SORTIE,I_SORTIE)]
    return chemins

def simulation(parking,parking_ref):
    """
    Simule les tutures
    """
    chemins_sortie = etapes_sortie(parking)

    voitures = [[[0,largeur_parking//2],1,False]] # [coords, direction, est_garee]

    Ntot_voitures = 50 # nb total de voitures qui apparaîtront
    T_moy_garage = 0
    T_moy_sortie = 0
    
    for i in range(N_ITERATIONS): # pour chaque itération de temps
        #print(i,voitures,voitures[0],'\n')
        
        if i%3 == 0 and i != 0:
            voitures.append([[0,largeur_parking//2],1,False])

        for num_voiture in range(len(voitures)):
            voiture = voitures[num_voiture]
            [x,y] = voiture[0]
            if not voiture[2]: # si la voiture n'est pas garée
                #print('pagaree')
                direction = voiture[1]

                candidats_dir_dispo = directions_dispo(x,y,direction,parking)
                
                direction_opposee = direction+2
                if direction_opposee > 4:
                    direction_opposee %= 4

                dir_dispo = []
                dir_place = []

                for num_dir in range(len(candidats_dir_dispo)): # on teste chaque direction autour de la voiture
                    if num_dir != direction_opposee: # elle n'a pas le droit de faire demi-tour
                        x_dir,y_dir = candidats_dir_dispo[num_dir][2],candidats_dir_dispo[num_dir][1]
                        # il ne faut pas collisionner avec une autre voiture aussi 
                        if candidats_dir_dispo[num_dir][0] and 0 <= parking[0][y_dir,x_dir] <= 1: # si la direction est accessible et n'est pas bloquée
                            if parking[0][y_dir,x_dir] == 1: # si c'est une place
                                dir_place.append([candidats_dir_dispo[num_dir][2],candidats_dir_dispo[num_dir][1],num_dir+1])
                            else: # si c'est de la route
                                dir_dispo.append([candidats_dir_dispo[num_dir][2],candidats_dir_dispo[num_dir][1],num_dir+1])
                
                parking[0][voiture[0][1],voiture[0][0]] = parking_ref[0][voiture[0][1],voiture[0][0]]

                if dir_place != []: # la voiture va en priorité à la place s'il y en a une
                    voiture = [[dir_place[0][0],dir_place[0][1]],dir_place[0][2],True]
                    
                elif dir_dispo != []: # sinon elle avance (si possible) là où elle peut
                    voiture = [[dir_dispo[0][0],dir_dispo[0][1]],dir_dispo[0][2],False]
                    print("avance",voiture)
                T_moy_garage += 1/Ntot_voitures

                parking[0][voiture[0][1],voiture[0][0]] = 2
                    
            else: # si la voiture est garée, elle suit un chemin prédéfini pour sortir
                if len(voiture) == 3: # si la voiture vient juste de se garer
                    try:
                        chemin_sortie = chemins_sortie[x,y]
                    except KeyError:
                        print('PABO >>',chemins_sortie.keys(),voiture)

                    voiture.append(chemin_sortie)
                    duree_garage = 10 #s/iterations
                    voiture.append(-duree_garage)
                
                T_moy_sortie += 1/Ntot_voitures
                if voiture[4] != len(voiture[3]): # si la voiture n'est pas arrivée
                    # ajouter qu'il ne pas rentrer dans une voiture
                    if voiture[4] > 0: # la tuture attend
                        parking[0][voiture[0][1],voiture[0][0]] = parking_ref[0][voiture[0][1],voiture[0][0]]
                        voiture[0] = voiture[3][voiture[4]] # on change les coordonnées de la voiture
                        parking[0][voiture[0][1],voiture[0][0]] = 2
                    voiture[4] += 1 # l'indice_etape_sortie augmente de 1

                else: # si la voiture est arrivée devant la sortie
                    print('arrivee')
                    pass # il faut trouver un moyen de vanish les tutures
            voitures[num_voiture] = voiture

        tab[i] = parking[0] # pour afficher en loop

    if T_moy_sortie == 0:
        T_moy_sortie = 100000
    
    return T_moy_garage,T_moy_sortie

def score(parking):
    """
    Renvoie le score du parking.
    Ce score est basé sur:
    - la durée moyenne de processus de garage
    - la durée moyenne de sortie du parking
    - le nombre de murs (il faut des arbres)       # À réfléchir...
    - le nombre de places

    Parameters
    ----------
    parking: array     # on suppose que le parking n'est plus une array linéaire mais rectangulaire

    Returns
    -------
    score: float
        Note positive = 1/(3*t_moy_garage) + 1/(3*t_moy_sortie) + nb_murs/12 + 3*nb_places/12
        Plus la note est basse, meilleur est le parking.
    """

    nb_murs, nb_places = np.count_nonzero(parking[0]==-1),np.count_nonzero(parking[0]==1)
    parking_ref = parking.copy()
    t_moy_garage,t_moy_sortie = simulation(parking,parking_ref)
    #print('score:',int(t_moy_garage),int(t_moy_sortie),nb_murs,nb_places)
    return t_moy_garage + t_moy_sortie - nb_murs/50 - nb_places # plus le score est faible meilleur le parking est

def selection(liste_parkings,nb_parkings):
    """
    Sélectionne la moitié des meilleurs parkings selon leur score
    """

    resultats = [] # j'ai pas réussi à faire autrement...
    
    for num_parking in range(nb_parkings):
        resultats.append([score(liste_parkings[num_parking]),num_parking])
    resultats = np.array(resultats)
    resultats = resultats[resultats[:,0].astype(int).argsort()]

    premiers_meilleurs = [liste_parkings[int(resultats[i][1])] for i in range(nb_parkings//2)] # on garde la moitié des meilleurs parkings
    
    return premiers_meilleurs

def croisement(liste_parkings,nb_parkings):
    """
    Procédure croisant les chromosomes des parkings
    Regroupés par couples, chaque paire de parkings sélectionnés croisent leur chromosomes pour donner 2 enfants
    On fait dans un premier temps un croisement simple
    """

    for i in range(0,nb_parkings//2,2):
        parent1 , parent2 = liste_parkings[i] , liste_parkings[i+1]
        
        enfant1 = np.array([np.concatenate((parent1[k][:largeur_parking//2],parent2[k][largeur_parking//2:])) for k in range(5)])
        enfant2 = np.array([np.concatenate((parent2[k][:largeur_parking//2],parent1[k][largeur_parking//2:])) for k in range(5)])
        liste_parkings.append(enfant1)
        liste_parkings.append(enfant2)
    
def mutation(liste_parkings):
    """
    De façon alétoire, chaque parking a pour chaque chromosome une toute petite probabilité d'avoir un gène qui mute aléatoirement
    """
    for parking in liste_parkings:
        for i in range(len(parking[0][:,0])):
            for j in range(len(parking[0][0])):
                num_gene = randint(0,4) # on choisit aléatoirement un gène
                if random()<0.005:
                    if num_gene == 0:
                        parking[I_TYPE_CASE][i,j] = randint(-1,1) # le type de bloc peut être le même
                    else:
                        parking[num_gene][i,j] = not(parking[num_gene][i,j])

def evolution(N_parkings,N_generations):
    '''
    Algorithme génétique pour une population de N parking.
    '''
    
    pop_parkings = [creation_random_parking(longueur_parking,largeur_parking) for _ in range(N_parkings)] # population initiale: on crée N parkings (durée: 0.06s)

    for _ in range(N_generations):
        pop_parkings = selection(pop_parkings,N_parkings)
        croisement(pop_parkings,N_parkings)
        mutation(pop_parkings)

    
    meilleur_parking = selection(pop_parkings,N_parkings)[0]
    
    return meilleur_parking

### FONCTION D'AFFICHAGE ###############################################

def affichage(tab):

    tab = tab[0] # on ne prend que les premiers indices pour l'afficher
    tab = np.array(tab,dtype=int)

    # Initialisation fenetre
    fig, ax = plt.subplots(figsize=(0.2*longueur_parking, 0.2*largeur_parking))

    # Dessin du tableau
    image = plt.imshow(tab, vmin=-1, vmax=2)
    
    ax = plt.gca()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
    plt.set_cmap('BrBG') #gist_gray ou bone

    plt.show()

def affichage_loop(tab):
    # Initialisation fenetre
    fig, ax = plt.subplots(figsize=(0.2*longueur_parking, 0.2*largeur_parking))

    # Dessin du tableau
    image = plt.imshow(tab[0], vmin=-1, vmax=2)
    
    # Animation
    N_t = tab.shape[0]
    ani = animation.FuncAnimation(fig, update_ani, frames = N_t, interval = 100, fargs=(tab, image), repeat = True)

    ax = plt.gca()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
    plt.set_cmap('BrBG') #gist_gray ou bone

    plt.show()

def update_ani(i, tab, image): # mise à jour de l'animation

    image.set_data(tab[i]) #Mise à jour de l'image
    
    return True

### PROGRAMME PRINCIPAL ################################################

N_parkings = 100
N_generations = 1
'''
aff = input('Afficher le parking final sous forme de tableau (y/n): ')
print("Durée de calcul: \n- {} minutes (machines lycée) \n- {} minutes (pc portable)".format(int(N_generations*3.4//60),int(N_generations//60)))
parking_final = evolution(N_parkings,N_generations)

if aff == 'y':
    print(parking_final)
affichage(parking_final)
'''

P = parking_cool_test(longueur_parking,largeur_parking-2)

tab = np.zeros((N_ITERATIONS,largeur_parking,longueur_parking))

simulation(P,np.copy(P))
print(I_SORTIE,J_SORTIE,largeur_parking//2,longueur_parking)
affichage_loop(tab)
